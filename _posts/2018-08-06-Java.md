---
layout: post
title: Java
date: 2018-08-06 13:32:20 +0300
description: my java . # Add post description (optional)
img: post-3.jpg # Add image post (optional)
tags: [Blog, Java]
author: hongtao # Add name author (optional)
---

# **Java**

标签 : 学习篇

---

今年暑假，抱着学习一下java的想法，阅读了Java编程思想这本书，没错，就是那本又大又厚的砖头书

---

> [TOC]


---
# 1.**全书的大致内容**
---

## 1.初始化与清理

> this关键字：
  1. this调用本类中的属性，也就是类中的成员变量
  2. this调用本类中的其他方法
  3. this调用本类中的其他构造方法，调用时放在构造方法的首行
  4. 返回对象的值，this除了可以引用变量或者成员方法之外，还有一个重大的作用就是返回类的引用，代码中，可以使用return this返回某个类的引用
  
  
> 总结一下对象的创建过程，假设有一个名为Sandwich的类
    1.即使没有显式的使用static关键字，构造器上实际上也是静态方法，因此，当首次创建Sandwich的对象时，或者Sandwich类的静态方法/静态域首次被访问时，java解释器必须查找类路径，以定位Sandwich.class文件，然后载入此文件，有关静态初始化的所有动作都将被执行，因此，静态方法只在Class对象首次加载的时候进行一次
    2.当用new Sandwich()创建对象时，首先在堆上为Dog对象分配足够的空间
    3.这块储存空间会被清零，这就自动的将Sandwich对象中的所有基本类型数据都设成了默认值（对于数字来说就是0，对于布尔型和字符型也相同），而对象的引用则被设置成了null
    4.执行所有出现在字段定义处的初始化动作
    5.执行构造器，如果Sandwich类是继承而来那么首先调用基类构造器，这个步骤会反复的递归下去，首先是构造这种层次的根，然后是下一曾导出类，等等，直到最底层的导出类；然后按声明顺序调用成员的初始化方法；最后调用导出类的构造器主体。


---

## 2.访问限权
Java用三个关键字在内的内部设定边界：
> * 默认访问限权即包访问限权（有时候也表示成为friendly），这就意味着当前包内的所有的其他类对那个成员都有访问限权，但对于这个包以外的所有类，这个成员确实private。
> * 使用public类型，就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。
> * 使用private类型，除了包含该成员的类之外，任何其他的任何类都无法访问这个成员。由于处于同一个包内的其他类是不可以访问private的成员的，因此这等于说是自己隔离了自己；从另一个方面说，让许多人共同合作来创建一个包是不大可能的，为此private就允许你随意的改变该成员，而不必考虑这样做会不会影响包内其他的类
> * protected继承类访问限权，要想了解这一部分内容，必须对继承有一个相对的理解

```
import access.dessert. *;

public class ChololateChip extends Cookie{
  public ChololateChip(){
    System.out.println("ChololateChip Constructor");
    }
    public void Chomp(){
    //! bite(); //can't access bite
    }
    public static void main[Strings[] args]{
      ChololateChip x = new ChololateChip();
      x.chomp();
    }
} /* Output:
Cookie constructor
ChololateChip constrctor
*///:~
```
> 如果类Cookie中存在一个方法bite（）的话，那么该方法同时也存在于任何一个从Cookie继承而来的类中，但是由于bite() 有包访问限权而且它是位于另一个包内，所以我们在这个包内是无法使用它的。当然，也可以把它指定为public，但是这样做所有人就都有了访问限权，所以可以将该方法指定为protected，那么bite()对于所有继承于Cookie的类而言都是可用的。

---

## 3.复用类

面向对象编程讲究的是代码复用,`继承` 和 `组合` 都是代码复用的有效方法。组合是将其他类的对象作为成员使用，继承是子类可以使用父类的成员方法。引用一个生动的比方：继承是说“我父亲在家里给我帮了很大的忙”，组合是说“我请了个老头在我家里干活”。

### 组合语法：
> 只需要将对象引用置于新类中即可，经常被视为“has-a”关系，就行我们所说的汽车拥有引擎一样。

```graphLR
    A[对象] --> |引用| B[新类]
    C[对象] --> |引用| B[新类]
```
### 继承语法：
> 以现有类为基础，复制它，然后通过添加或修改这个副本来创建新类那就要好多了，通过继承便可达到此效果，不过，当基类发生变动时，导出类也会反应出这种变化、经常被视为“is-a”（覆盖基类方法不添加） "is-like-a"（添加新的接口元素）关系

```graphLR
   A[导出类1] --> |继承| B[基类]
   C[导出类2] --> |继承| B[基类]
```
### 代理：
> 第三种关系称之为代理，Java并没有提供对他的直接支持，但这是继承与组合之间的中庸之道，我们在使用代理时，通常将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该对象成员的所有方法（就像继承），例如，太空船需要一个控制模块：

```
public class SpaceShipControls{
  void up(int velcity){}
  void down(int velcity){}
  void left(int velcity){}
  void right(int velcity){}
  void forward(int velcity){}
  void back(int velcity){}
  void turboBoost{}
}

public class SpaceShipDelegation{
  private String name;
  private SpaceShipControls controls=
    new SpaceShipControls();
  public SpaceShipDelegation(String name){
    this.name = name;
  }
  //Delegate methods
  public void back(int velcity){
    controls.back(velcity);
  }
  public void down(int velcity){
    controls.down(velcity);
  }
  public void forward(int velcity){
    controls.forward(velcity);
  }
  public void left(int velcity){
    controls.left(velcity);
  }
  public void right(int velcity){
    controls.right(velcity);
  }
  public void up(int velcity){
    controls.up(velcity);
  }
  public void turboBoost(){
    controls.turboBoost();
  }
  public static void main[Strings[] args]{
    SpaceShipDelegation protector = 
      new SpaceShipDelegation("NSEA protector");
    protector.forward(100);
  }
}
```

> 可以看到，上面的方法是如何传递给了底层的controls对象，而其接口也由此就与使用继承得到的接口相同了，到是我们使用代理可以得到更多的控制力，因此我们可以选择只提供在成员对象中的方法中的某个子集。

### final关键字：
final被用到的情况有三种：数据 方法 和类
#### final数据：

> * 在java中，编译类型常量必须是基本数据类型，并且以关键字final表示，对于这种常量进行定义的时候，必须对其进行赋值。
> * 一个即是static又是final的域[^footnote] 只占据一段不能改变的储存空间
> * 对于基本类型的，final使数值恒定不变，而用于对象，final使引用恒不变，一但引用被初始化指向一个对象，就无法再把它指向另一个对象，然而，对象其自身却是可以被修改的，这一限制同样适用于数组
> * 空白final: 所谓空白final是指被声明为final但又未给定初值的域。但是无论什么情况，编译器都确保空白final在使用前必须被初始化，因此，一个类中的空白final域可以做到根据对象不同而有所不同，却又保持其恒定不变得特性，下面即为一例:

```
class Poppet{
  private int i;
  Poppet(int ii){i=ii;}
}

public class BlankFinal{
  private final int i = 0;//initialized final
  private final int j;//Blank final
  private final Poppet p;//Blank final reference
  //Blank finals must be initialized in the constructor:
  public BlankFinal(){
    j = 1;//initialize blank final
    p = new Poppet(1);//initialize blank final reference
  }
  public BlankFinal(int x){
    j = x;
    p = new Poppet(x);
  }
  public static void main[String[] args]{
    new BlankFinal();
    //new BlankFinal(47);
  }
}///:~
```

> * final参数: Java允许在参数列表中以声明的形式将参数指定为final，这意味着你无法再方法中更改参数引用所指的对象

#### final方法
使用final方法得原因主要有两个
> * 第一个原因是把方法锁定，以防止任何继承类修改它的含义，保证这个方法不会被覆盖
> * 提高代码效率（目前已经逐渐被舍弃）
> * 注意：类中所有的private方法都被隐式的指定为是final的，由于无法取用，自然也就无法覆盖，覆盖：只有在某方法基类接口的一部分时才有机会出现，不然在导出类中的同名方法只能被看作是生成了一个新的方法，并不算是覆盖

#### final类
> 将某个类得整体定义为final时，就表明你不打算继承该类，而且也不允许别人这么做，话句话说，出于某种考虑，你对该类的设计不需要任何变动，或者出于安全考虑，你不希望它有子类

---

## 4.多态

### 向上转型
> 对象既可以作它自己本身的类型使用，也可以作为它的基本类型使用，这种把某个对象的引用时位对其基类的引用叫做向上转型，下面有一个例子
```
public enum Note{
    MIDDLE_C, C_SHARP, B_FLAT;//Etc.
}

class Instrument{
    public void play(Note n){
        System.out.println("Instrument.play()");
    }
}

class Wind extends Instrument{
    //redefine interface method
    public void play(Note n){
        System.out.println("Wind.play()"+n);
    }
}

class Stringed extends Instrument{
    public void play(Note n){
        System.out.println("Stringed.play()"+n);
    }
}

class Brass extends Instrument{
    public void play(Note n){
        System.out.println("Brass.play()"+n);
    }
}

public class Music{
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind flute = new Wind();
        Stringed violin = new Stringed();
        Brass frenchHorn = new Brass();
        tune(flute);
        tune(violin);
        tune(frenchHorn);
    }
}/*Output:
Wind.play()MIDDLE_C
Stringed.play()MIDDLE_C
Brass.play()MIDDLE_C
*///~
```

> 引用多态： 父类的引用既可以指向本类的对象，也可以指向子类的对象。方法多态：创建本类对象时，调用的方法为本类方法，创建子类对象时，调用的是子类重写的或者继承的方法
> 编译器是如何知道这个Instrument引用指向的是Wind对象，而不是Brass或者stringed对象呢，这就和方法调用的绑定有关。
方法调用绑定：
:    将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定，是一种默认绑定方式，C语言只有这一种绑定方式。本例解决的方法是后期绑定，它的含义是在运行时根据对象的类型进行后期绑定，后期绑定机制随编程语言的不同而有所不同，但是只要想一下就会得知，不管怎么样都必须在对象中安置某种"类型信息"。






[^footnote]: 域:field，是一种属性，可以是一个类的变量，一个对象的变量，一个对象中方法的变量，亦或者是一个函数的参数。


[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
