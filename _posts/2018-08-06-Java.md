---
layout: post
title: Java
date: 2018-08-06 13:32:20 +0300
description: my java . # Add post description (optional)
img: post-3.jpg # Add image post (optional)
tags: [Blog, Java]
author: hongtao # Add name author (optional)
---

# **Java**

标签 : 学习篇

---

> [TOC]

---

## **自己的博客**

### 1.为什么创建自己的博客

开通博客无非是~~为了装逼~~为自己的学习或生活做一个记录，我也是想记录一下自己的大学生活，毕竟谁也不 想混个四年是吧，我的文笔差劲的很，如何有其他的人看我的博客，应该会很难受吧，哈哈，那就没办法了

---

### 2.如何创建一个自己的博客

>* 首先我利用github.io创建了一个最简的博客，选用的是官方推送的几个主题之一，网上教程贼多
>* 如果你只想要一个最简单能够发布的博客的话，那么以上步骤就足以满足你了，如果你像我这样想要骚气一点的话，你可以继续往下看
>* 首先去下载ruby并安装，然后再去下载Devikit并安装，(由于网络问题，不翻墙的话是无法下载官方文件的，但是国内的软件网站有很多的下载途径)，下载完成后进入ruby，输入 `$ gem install jekyll` 安装jekyll，输入`$ jekyll -vv`查看是否安装完成
>* jekyll tree的结构一般如下
```
├── _config.yml
├── _includes
|   ├── footer.html
|   └── header.html
├── _layouts
|   ├── default.html
|   ├── post.html
|   └── page.html
├── _posts
|   └── 2018-01-11-welcome-to-jekyll.md
├── _sass
|   ├── _base.scss
|   ├── _layout.scss
|   └── _syntax-highlighting.scss
├── about.md
├── css
|   └── main.scss
├── feed.xml
└── index.html
```
>* 安装完成后，你就可以去[选择jekyll模板了](http://jekyllthemes.org/)
>* 选择好后，将你所看中的模板下载下来，将文件复制到你的github.io库的本地库文件中（需要提前clone到本地），改变其中的config文件，将所需的配置改为你自己的，就大功告成啦！

---

### 3.如何去书写自己的博客

由于githu.io支持的是markdown语法书写，所以用github做博客的朋友要花一点时间去学习一下，其实markdown语言是十分简单的，学起来非常快。

#### 1.什么是markdown:
> Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。

#### 2.如何使用markdown:
> 看一下这个吧[markdown手册](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown)，很快就能学会

#### 3.怎样去写博客
> * 找到你本地库的文件夹，打开_post文件夹，找到其中模板中存在的一片博客，对它重命名，记住，一定要是用YYY-MMM-DDD-Title.md(或者.markdown)形式命名，然后用cmd markdown这款编辑器打开该文件进行重编辑，对于YAML头信息中的内容改几个你觉得有必要改的就行了，类似于 :
```
---
layout: post
title: hello world
tags: tag1 tag2
---
```
> * 对于尾部信息就不要改了，类似于:
```
[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
```
> * 博客的内容只要把模板的内容换成自己的就行了
> * 修改完后，你使用ruby命令行进入本地库，run ` jekyll serve` ，这时候我出了一个问题，` invalid byte sequence in Utf-8` 怎么办呢？不要慌，使用notepad++打开这个博客文件，在编码中，选择 ` 转为utf-8-BOM编码` ,然后再次run ` jekyll serve` 就大功告成了!
> * 使用` git commit -a -m "first blog"` ,将修改的本地文件提交到暂存区并提交，然后` git push` 就行了
> * [我的博客地址](https://taohonghk.github.io)


---

## **搞一下Java**
今年暑假，抱着学习一下java的想法，阅读了Java编程思想这本书，没错，就是那本又大又厚的砖头书

---
### 1.全书的大致内容
---
#### 1.访问限权
Java用三个关键字在内的内部设定边界：
> * 默认访问限权即包访问限权（有时候也表示成为friendly），这就意味着当前包内的所有的其他类对那个成员都有访问限权，但对于这个包以外的所有类，这个成员确实private。
> * 使用public类型，就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。
> * 使用private类型，除了包含该成员的类之外，任何其他的任何类都无法访问这个成员。由于处于同一个包内的其他类是不可以访问private的成员的，因此这等于说是自己隔离了自己；从另一个方面说，让许多人共同合作来创建一个包是不大可能的，为此private就允许你随意的改变该成员，而不必考虑这样做会不会影响包内其他的类
> * protected继承类访问限权，要想了解这一部分内容，必须对继承有一个相对的理解
```java
import access.dessert. *;

public class ChololateChip extends Cookie{
  public ChololateChip(){
    System.out.println("ChololateChip Constructor");
    }
    public void Chomp(){
    //! bite(); //can't access bite
    }
    public static void main[Strings[] args]{
      ChololateChip x = new ChololateChip();
      x.chomp();
    }
} /* Output:
Cookie constructor
ChololateChip constrctor
*///:~
```
> 如果类Cookie中存在一个方法bite（）的话，那么该方法同时也存在于任何一个从Cookie继承而来的类中，但是由于bite() 有包访问限权而且它是位于另一个包内，所以我们在这个包内是无法使用它的。当然，也可以把它指定为public，但是这样做所有人就都有了访问限权，所以可以将该方法指定为protected，那么bite()对于所有继承于Cookie的类而言都是可用的。

---

#### 2.复用类

面向对象编程讲究的是代码复用,`继承` 和 `组合` 都是代码复用的有效方法。组合是将其他类的对象作为成员使用，继承是子类可以使用父类的成员方法。引用一个生动的比方：继承是说“我父亲在家里给我帮了很大的忙”，组合是说“我请了个老头在我家里干活”。

##### 组合语法：
> 只需要将对象引用置于新类中即可，经常被视为“has-a”关系，就行我们所说的汽车拥有引擎一样。
```graphLR
    A[对象] --> |引用| B[新类]
    C[对象] --> |引用| B[新类]
```
##### 继承语法：
> 以现有类为基础，复制它，然后通过添加或修改这个副本来创建新类那就要好多了，通过继承便可达到此效果，不过，当基类发生变动时，导出类也会反应出这种变化、经常被视为“is-a”（覆盖基类方法不添加） "is-like-a"（添加新的接口元素）关系

```graphLR
   A[导出类1] --> |继承| B[基类]
   C[导出类2] --> |继承| B[基类]
```
##### 代理：
> 第三种关系称之为代理，Java并没有提供对他的直接支持，但这是继承与组合之间的中庸之道，我们在使用代理时，通常将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该对象成员的所有方法（就像继承），例如，太空船需要一个控制模块：
```java
public class SpaceShipControls{
  void up(int velcity){}
  void down(int velcity){}
  void left(int velcity){}
  void right(int velcity){}
  void forward(int velcity){}
  void back(int velcity){}
  void turboBoost{}
}

public class SpaceShipDelegation{
  private String name;
  private SpaceShipControls controls=
    new SpaceShipControls();
  public SpaceShipDelegation(String name){
    this.name = name;
  }
  //Delegate methods
  public void back(int velcity){
    controls.back(velcity);
  }
  public void down(int velcity){
    controls.down(velcity);
  }
  public void forward(int velcity){
    controls.forward(velcity);
  }
  public void left(int velcity){
    controls.left(velcity);
  }
  public void right(int velcity){
    controls.right(velcity);
  }
  public void up(int velcity){
    controls.up(velcity);
  }
  public void turboBoost(){
    controls.turboBoost();
  }
  public static void main[Strings[] args]{
    SpaceShipDelegation protector = 
      new SpaceShipDelegation("NSEA protector");
    protector.forward(100);
  }
}
```
> 可以看到，上面的方法是如何传递给了底层的controls对象，而其接口也由此就与使用继承得到的接口相同了，到是我们使用代理可以得到更多的控制力，因此我们可以选择只提供在成员对象中的方法中的某个子集。

##### final关键字：
###### final数据
在java中，编译类型常量











[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
