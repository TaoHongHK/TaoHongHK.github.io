---
layout: post
title: Java
date: 2018-08-06 13:32:20 +0300
description: my java . # Add post description (optional)
img: post-4.jpg # Add image post (optional)
tags: [Blog, Java]

---

# **Java**

标签 : 学习篇

---

今年暑假，抱着学习一下java的想法，看了一下java的书籍。

---

> [TOC]


---
# 1.**全书的大致内容**
---

## **1.初始化与清理**

### **类的加载过程**
1. 加载（loading）
(1). 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
(2). 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
(3). 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
2. 验证（Verification）
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作：
(1). 文件格式验证：验证字节流是否符合Class文件格式的规范(例如，是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型)
(2). 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求(例如：这个类是否有父类，除了java.lang.Object之外)；
(3). 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的;
(4). 符号引用验证：确保解析动作能正确执行.
3. 准备(Preparation)
准备阶段是正式为类变量(static 成员变量)分配内存并设置类变量初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为: `public static int value = 123;`
那么，变量value在准备阶段过后的值为0而不是123。
4. 解析(Resolution)
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
5. 初始化(Initialization)
类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。
在准备阶段，变量已经赋过一次系统要求的初始值(零值)；而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者更直接地说：初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

### **创建对象的过程**
**当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量(即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间)。在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。在内存分配完成之后，Java虚拟机就会开始对新创建的对象按照程序猿的意志进行初始化。在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 实例变量初始化、实例代码块初始化 以及 构造函数初始化。（从父类到子类）**

1. 我们在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。如果我们以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(还记得吗？Java要求构造函数的第一条语句必须是超类构造函数的调用语句)，构造函数本身的代码之前。
2. Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。事实上，这一点是在构造函数中保证的：Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用
3. 类构造器<clinit>()与实例构造器<init>()不同，它不需要程序员进行显式调用，虚拟机会保证在子类类构造器<clinit>()执行之前，父类的类构造<clinit>()执行完毕。由于父类的构造器<clinit>()先执行，也就意味着父类中定义的静态代码块/静态变量的初始化要优先于子类的静态代码块/静态变量的初始化执行。特别地，类构造器<clinit>()对于类或者接口来说并不是必需的，如果一个类中没有静态代码块，也没有对类变量的赋值操作，那么编译器可以不为这个类生产类构造器<clinit>()。此外，在同一个类加载器下，一个类只会被初始化一次，但是一个类可以任意地实例化对象。也就是说，在一个类的生命周期中，类构造器<clinit>()最多会被虚拟机调用一次，而实例构造器<init>()则会被虚拟机调用多次，只要程序员还在创建对象。
4. 一个实例变量在对象初始化的过程中会被赋值几次？
我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值，这个赋值过程是没有办法避免的。如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。也就是说，在Java的对象初始化过程中，一个实例变量最多可以被初始化4次。
5. 类的初始化过程与类的实例化过程的异同？
类的初始化是指类加载过程中的初始化阶段对类变量按照程序猿的意图进行赋值的过程；而类的实例化是指在类完全加载到内存中后创建对象的过程。


**总的来说就是：父类的类构造器<clinit>() ->子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数 -> 子类的成员变量和实例代码块 -> 子类的构造函数。**
  
  
> 有关Java静态域、块，非静态域、块、构造函数的初始化顺序：
:    对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序以此是（静态变量、静态初始化  块）>（变量、初始化块）>构造器。静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。且执行顺序为静态代码块------非静态代码块----构造函数。 

> 静态代码块  与  静态方法： 
:    一般情况下,如果有些代码必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的; 需要在项目启动的时候就初始化,在不创建对象的情况下,其他程序来调用的时候,需要使用静态方法,这种代码是被动执行的.两者的区别就是:静态代码块是自动执行的;  静态方法是被调用的时候才执行的.   作用:静态代码块可用来初始化一些项目最常用的变量或对象;静态方法可用作不创建对象也可能需要执行的代码；[详细请戳这里](https://www.cnblogs.com/vinozly/p/5255312.html)


#### **this关键字：**
  1. this调用本类中的属性，也就是类中的成员变量
  2. this调用本类中的其他方法
  3. this调用本类中的其他构造方法，调用时放在构造方法的首行
  4. 返回对象的值，this除了可以引用变量或者成员方法之外，还有一个重大的作用就是返回类的引用，代码中，可以使用return this返回某个类的引用
  
> 总的来说this就是**调用本类的属性和方法**

---

## **2.访问限权**

### **三个关键字**
Java用三个关键字在内的内部设定边界：
> * 默认访问限权即包访问限权（有时候也表示成为friendly），这就意味着当前包内的所有的其他类对那个成员都有访问限权，但对于这个包以外的所有类，这个成员确实private。
> * 使用public类型，就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。
> * 使用private类型，除了包含该成员的类之外，任何其他的任何类都无法访问这个成员。由于处于同一个包内的其他类是不可以访问private的成员的，因此这等于说是自己隔离了自己；从另一个方面说，让许多人共同合作来创建一个包是不大可能的，为此private就允许你随意的改变该成员，而不必考虑这样做会不会影响包内其他的类
> * protected继承类访问限权，要想了解这一部分内容，必须对继承有一个相对的理解

```
import access.dessert. *;

public class ChololateChip extends Cookie{
  public ChololateChip(){
    System.out.println("ChololateChip Constructor");
    }
    public void Chomp(){
    //! bite(); //can't access bite
    }
    public static void main[Strings[] args]{
      ChololateChip x = new ChololateChip();
      x.chomp();
    }
} /* Output:
Cookie constructor
ChololateChip constrctor
*///:~
```
如果类Cookie中存在一个方法bite（）的话，那么该方法同时也存在于任何一个从Cookie继承而来的类中，但是由于bite() 有包访问限权而且它是位于另一个包内，所以我们在这个包内是无法使用它的。当然，也可以把它指定为public，但是这样做所有人就都有了访问限权，所以可以将该方法指定为protected，那么bite()对于所有继承于Cookie的类而言都是可用的。

### **封装**
非要说的话，封装由两个步骤组成：
1. 对一个类的内部（成员变量和方法）进行隐藏
2. 开放部分（广义的）接口供外部访问


封装的目的：实现模块化，降低耦合

---

## **3.复用类**

面向对象编程讲究的是代码复用,**继承**和**组合**都是代码复用的有效方法。组合是将其他类的对象作为成员使用，继承是子类可以使用父类的成员方法。引用一个生动的比方：继承是说“我父亲在家里给我帮了很大的忙”，组合是说“我请了个老头在我家里干活”。

### **组合语法：**
只需要将对象引用置于新类中即可，经常被视为“has-a”关系，就行我们所说的汽车拥有引擎一样。

```graphRL
    A[对象] --> |引用| B[新类]
    C[对象] --> |引用| B[新类]
```

### **继承语法：**
以现有类为基础，复制它，然后通过添加或修改这个副本来创建新类那就要好多了，通过继承便可达到此效果，不过，当基类发生变动时，导出类也会反应出这种变化、经常被视为“is-a”（覆盖基类方法不添加） "is-like-a"（添加新的接口元素）关系
纵向：一个类共享一个或多个类中定义 的属性和行为，是一种泛化/特殊化的 层次关系。
横向：同类别的多个事物进行抽象，抽 取了它们的共性，放入父类中共享。

java中的继承是单继承的，一个子类只能继承一个父类，使用extends关键字。
继承是多层级的；
共同的祖先 java.lang.Object
子类继承了父类中所有非private成员方法（除了构造方法）和所有非private的成员变量。
父类中的final成员无法被继承

在生成子类实例时，虚拟机就已经在实例空间中为父类对象分配了空间，子类可以通过super关键字获得指向父类对象的引用，但是父类的私有成员是无法被直接访问的，并没有继承

一般情况下来说，父类的中的成员往往是最委屈的，子类要是有个同名(仅仅需要名字一样)成员，自己的成员就会被隐藏，子类还可以访问自己的非私有成员，但是自己想访问子类中的成员就不行，当子类与自己有同名的成员时，访问到的是自己的成员，没有同名成员时意图直接访问子类成员则直接报错.......这是何等悲惨，为此，我们应该做些什么来为父类谋得一些权利，让父类可以顺利的访问子类非费私有成员。


```graphRL
   A[导出类1] --> |继承| B[基类]
   C[导出类2] --> |继承| B[基类]
```

#### **super**

```
class parent{
    public String name = "parent";
    public void print(){
        System.out.println(name+this.getClass.getSimpleName());
    }
}

class child extends parent{
    public String name = "child";
    public void print(){
       System.out.println(name+this.getClass.getSimpleName());
    }
}
```

因为super并没有代表超类的一个引用的能力，只是代表调用父类的方法而已。所以，在子类的方法中，不能这样用System.out.println(super);也不能使用super.super.mathod();
事实上，super.getClass()是表示调用父类的方法。getClass方法来自Object类，它返回对象在运行时的类型。因为在运行时的对象类型是Test，所以this.getClass()和super.getClass()都是返回Test。


### **代理：**
第三种关系称之为代理，Java并没有提供对他的直接支持，但这是继承与组合之间的中庸之道，我们在使用代理时，通常将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该对象成员的所有方法（就像继承），例如，太空船需要一个控制模块：

```
public class SpaceShipControls{
  void up(int velcity){}
  void down(int velcity){}
  void left(int velcity){}
  void right(int velcity){}
  void forward(int velcity){}
  void back(int velcity){}
  void turboBoost{}
}

public class SpaceShipDelegation{
  private String name;
  private SpaceShipControls controls=
    new SpaceShipControls();
  public SpaceShipDelegation(String name){
    this.name = name;
  }
  //Delegate methods
  public void back(int velcity){
    controls.back(velcity);
  }
  public void down(int velcity){
    controls.down(velcity);
  }
  public void forward(int velcity){
    controls.forward(velcity);
  }
  public void left(int velcity){
    controls.left(velcity);
  }
  public void right(int velcity){
    controls.right(velcity);
  }
  public void up(int velcity){
    controls.up(velcity);
  }
  public void turboBoost(){
    controls.turboBoost();
  }
  public static void main[Strings[] args]{
    SpaceShipDelegation protector = 
      new SpaceShipDelegation("NSEA protector");
    protector.forward(100);
  }
}
```

> 可以看到，上面的方法是如何传递给了底层的controls对象，而其接口也由此就与使用继承得到的接口相同了，到是我们使用代理可以得到更多的控制力，因此我们可以选择只提供在成员对象中的方法中的某个子集。

### **final关键字：**
final被用到的情况有三种：数据 方法 和类
#### **final数据：**

> * 编译期常量： 在java中，编译类型常量必须是基本数据类型，并且以关键字final表示，对于这种常量进行定义的时候，必须对其进行赋值，如`static final int staticFinal = 10；`属于编译期常量，在使用`classname.staticFinal`访问时不需要对classname这个类进行初始化,但如果staticFinal是
```
Random rand = new Random(47);
static final int staticFinal = rand.nextInt(20); 
```
则不是编译期常量，对`classname.staticFinal`的访问将强制进行类的初始化，如果一个static域不是final的，那么在对它访问时，要求在被读取之前先进性链接（为这个域分配储存空间），和初始化（初始化该储存空间）
> * 一个即是static又是final的域[^footnote] 只占据一段不能改变的储存空间
> * 对于基本类型的，final使数值恒定不变，而用于对象，final使引用恒不变，一但引用被初始化指向一个对象，就无法再把它指向另一个对象，然而，对象其自身却是可以被修改的，这一限制同样适用于数组
> * 空白final: 所谓空白final是指被声明为final但又未给定初值的域。但是无论什么情况，编译器都确保空白final在使用前必须被初始化，因此，一个类中的空白final域可以做到根据对象不同而有所不同，却又保持其恒定不变得特性，下面即为一例:

```
class Poppet{
  private int i;
  Poppet(int ii){i=ii;}
}

public class BlankFinal{
  private final int i = 0;//initialized final
  private final int j;//Blank final
  private final Poppet p;//Blank final reference
  //Blank finals must be initialized in the constructor:
  public BlankFinal(){
    j = 1;//initialize blank final
    p = new Poppet(1);//initialize blank final reference
  }
  public BlankFinal(int x){
    j = x;
    p = new Poppet(x);
  }
  public static void main[String[] args]{
    new BlankFinal();
    //new BlankFinal(47);
  }
}///:~
```

> * final参数: Java允许在参数列表中以声明的形式将参数指定为final，这意味着你无法再方法中更改参数引用所指的对象

#### **final方法**
使用final方法得原因主要有两个
> * 第一个原因是把方法锁定，以防止任何继承类修改它的含义，保证这个方法不会被覆盖
> * 提高代码效率（目前已经逐渐被舍弃）
> * 注意：类中所有的private方法都被隐式的指定为是final的，由于无法取用，自然也就无法覆盖，覆盖：只有在某方法基类接口的一部分时才有机会出现，不然在导出类中的同名方法只能被看作是生成了一个新的方法，并不算是覆盖

#### **final类**
>将某个类得整体定义为final时，就表明你不打算继承该类，而且也不允许别人这么做，话句话说，出于某种考虑，你对该类的设计不需要任何变动，或者出于安全考虑，你不希望它有子类

---

## **4.多态**

### **意义与实现**
> * 多态是同一个行为具有多个不同表现形式或形态的能力；也就是同一个接口，使用不同的实例而执行不同操作
> * 多态就是子类重写了父类的接口，通过父类引用指向不同的子类对象，调用子类对象中的实现方法，从而实现一个接口实现不同的操作
> * 多态与重载的区别：重载，是指允许存在多个同名方法，而这些方法的参数不同。重载的实现是：编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它的调用地址在编译期就绑定了，属于前期绑定。多态是指子类重新定义父类的虚方法（virtual,abstract）。当子类重新定义了父类的虚方法后，父类根据赋给它的不同的子类，动态调用属于子类的该方法，这样的方法调用在编译期间是无法确定的，属于后期绑定。
> * 实现多态可以通过
1. 重写
2. 接口
3. 抽象类和抽象方法

### **重写与重载的区别**
重写的要求：
1. 参数列表必须完全与被重写方法的相同；
2. 返回类型必须完全与被重写方法的返回类型相同（或为子类型）；
3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
4. 父类的成员方法只能被它的子类重写。
5. 声明为final的方法不能被重写。
6. 声明为static的方法不能被重写，但是能够被再次声明。
7. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
8. 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
9. 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
10. 构造方法不能被重写。
11. 如果不能继承一个方法，则不能重写这个方法。

重载的要求：
1. 被重载的方法必须改变参数列表(参数个数或类型不一样)；
2. 被重载的方法可以改变返回类型；
3. 被重载的方法可以改变访问修饰符；
4. 被重载的方法可以声明新的或更广的检查异常；
5. 方法能够在同一个类中或者在一个子类中被重载。
6. 无法以返回值类型作为重载函数的区分标准。

区别：
|区别点|重载方法|重写方法|
|-------|-------|--------|
|函数名|一定不能修改|一定不能修改|
|参数类型|必须修改|一定不能修改|
|返回值类型|可以修改|返回值类型小于父类方法的返回值类型|
|访问限权|可以修改|访问限权大于等于父类方法的访问限权|
|异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常|


### **向上转型**
对象既可以作它自己本身的类型使用，也可以作为它的基本类型使用，这种把某个对象的引用时位对其基类的引用叫做向上转型，下面有一个例子

```
public enum Note{
    MIDDLE_C, C_SHARP, B_FLAT;//Etc.
}
class Instrument{
    public void play(Note n){
        System.out.println("Instrument.play()");
    }
}
class Wind extends Instrument{
    //redefine interface method
    public void play(Note n){
        System.out.println("Wind.play()"+n);
    }
}
class Stringed extends Instrument{
    public void play(Note n){
        System.out.println("Stringed.play()"+n);
    }
}
class Brass extends Instrument{
    public void play(Note n){
        System.out.println("Brass.play()"+n);
    }
}
public class Music{
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }
public static void main(String[] args) {
    Wind flute = new Wind();
    Stringed violin = new Stringed();
    Brass frenchHorn = new Brass();
    tune(flute);
    tune(violin);
    tune(frenchHorn);
    }
}/*Output:
Wind.play()MIDDLE_C
Stringed.play()MIDDLE_C
Brass.play()MIDDLE_C
*///~
```

引用多态:父类的引用既可以指向本类的对象，也可以指向子类的对象。方法多态：创建本类对象时，调用的方法为本类方法，创建子类对象时，调用的是子类重写的或者继承的方法

编译器是如何知道这个Instrument引用指向的是Wind对象，而不是Brass或者stringed对象呢，这就和方法调用的绑定有关。

### **方法调用绑定**
将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定，是一种默认绑定方式，C语言只有这一种绑定方式。本例解决的方法是后期绑定，它的含义是在运行时根据对象的类型进行后期绑定，后期绑定机制随编程语言的不同而有所不同，但是只要想一下就会得知，不管怎么样都必须在对象中安置某种"类型信息"。

### 剖析方法的重写:

```
public class OldParent {
    public String name = "OldParent";
    public OldParent(){
        print();
    }
    public void print(){
        System.out.println(name);
    }
}
public class Parent extends OldParent{
    public String name = "Parent";
    public Parent(){
        super();
        print();
    }
    public void print(){
        System.out.println(name);
    }
}
public class Child extends Parent{

    public String name = "child";
    public static void main(String[] args) {
        Child child = new Child();
    }
    public Child(){
        super();
        print();
    }
    public void print(){
        System.out.println(name);
    }
}
结果：
null
null
child
```

为什么会出现这种情况？当我们重写父类的方法时，如果通过子类对象调用父类中重写的方法，结果是全调用的是子类的方法。
那为什么前两个结果全是null？上面已经说的很清楚了，因为调用的是子类的方法，同样属性也是子类的属性。所以在父类中调用name，因为不能访问到子类的name,所以为null。
进一步理解就是： 
在child中：我们可以访问的属性有3个name:一个是child的，一个是Parent的，一个是OldParent的。我们在child中可以访问这三个name；在Paren中：我们可以访问的属性有2个name:一个是Parent的，一个是OldParent的，在OldParent中：我们可以访问的属性有1个name：就是自己的；所以，我们可以知道结果为什么是null,null,Child了吧！

此处不得不再次提一下父类的苦逼之处，父类的属性是在子类中是不存在重写的，只是覆盖，只有方法是重写，如果父类和子类有同名属性，

---

## **5.接口**

### **抽象类和抽象方法**
在前一章乐器的例子中，基类Instrument中的方法往往是“哑”的，这是因为Instrument类的目的就是为它所有的导出类创建一个通用接口，**不同的子类就可以用不同的方式表示此接口**，通用接口建立起一种基本形式，以此表示所有到处类的共同部分，我们将Instrument类称作抽象基类，简称抽象类。
Java提供一种抽象方法的机制，这种方法是不完整的，仅有声明而没有方法体，语法：`abstract void f();`，包含抽象方法得类叫做抽象类，如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的，否则就会报错。
如果从一个抽象类继承，并想创建该新类的对象，那么必须为基类中的所有抽象方法提供方法定义，如果不这么做，导出类便也是抽象类，且编译器会强制我们用abstract关键词来修饰这个类。
我们无法实例化一个抽象类，我们在实例化抽象类时会被要求实现抽象方法，我们实现的只是匿名子类

### **接口**
> * interface这个关键字产生一个完全抽象的类，它根本没有提供任何具体实现，它允许创建者们确定方法名，参数列表和返回类型，但是没有任何方法体。一个接口表示：“所有实现了该特定接口的类看起来都像一个样”

> * 接口中的类一定是public static的

> * 通过与多态性质的搭配，可以实现一个接口执行多种不同操作

> * 接口中的方法一定是public abstract的

> * 接口中的属性一定是public static final的，而且必须赋初值

```graphRL
    A[WoodWind]-->|extends| C[Wind];
    B[Brass]-->|extends| C[Wind];
    C[Wind]-->|implements| F[interface Instrument]
    D[Percussion]-->|implements| F[interface Instrument]
    E[Stringed]-->|implements| F[interface Instrument]
```



---

## **6.内部类**
将一个类定义在另一个类定义的内部，就是内部类

### **创建一个内部类**

```
public calss Parcel{
   class Contents{
     private int i = 11;
     public int value(){return i;}
     }
   class Destination{
     private String label;
     Destination(String whereTo){
       label = whereTo;
     }
     String readLabel(){return label;}
     }
   public Destination to(String dest){
     return new Destiantion();
     }
   public Contents contents(){
     return new Contents();
     }
   public void ship(String dest){
     Contents c = contents();
     Destination d = to(dest);
     System.out.println(d.readLabel());
     }
   public static void main(String[] args){
     Parcel p = new Parcel();
     p.ship("Tasmania");
     Parcel q = new Parcel();
     Parcel.Contents c = q.contents();
     Parcel.Destinaiton d = q.to("Tasmania");
     }
}
```

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须想在mian() 方法中的那样，具体的指出这个对象的类型：OuterClassName.InnerClassName.

### **内部类链接到外部类**
当生成一个内部类的对象时，此对象于制造它的外围对象(enclosing object)之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何其他的条件。此外，内部类还拥有其外围类所有元素的访问权，这是如何做到的呢，当某个外部类的对象创建了一个内部类的对象时，此内部类对象必定会秘密捕获一个指向那个外围对象的引用，当你访问此外围类的成员时，就是用那个引用来选择外围类的成员，所以非静态的内部类只有在于其外部类的对象相关联时才能被创建。

### **使用.this 与 .new**
如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用会自动拥有正确的类型

```
public class DotThis{
    void f(){System.out.println("DotThis.f()");}
    public class Inner{
        public DotThis outer(){
          return DotThis.this;
        }
    }
}
public Inner inner(){return new Inner();}
public static void main(String[] args){
  DotThis dt = new DotThis();
  DotThis.Inner dti = dt.Inner();
  dti.outer().f();
  }
}/* Output:
DotThis.f()
*///:~
```

如果你想用外围对象去创建某个内部对象，要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这时需要使用.new语法

```
public class DotNew{
    public class Inner{}
    public static void main(String[] args){
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
        }
}///:~
```

在拥有外部类对象之前是不可能创建内部类对象的，这是因为内部类对象会暗暗的来年街道创建他的外部类对象上。

### **内部类向上转型**
当一个内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。

```
public interface Destination{
    String readLabel();
}///:~

public interface Contents{
    int value();
}///:~

class Parcel{
    private class pContents implements Contents{
        private int i = 11;
        public int value(){return i;}
    }
    protected class pDestination implements Destination{
        private String label;
        private PDestination(String whereTo){
            label = whereTo;
        }
        public String readLabel(){return label;}
    }
    public Destination destination(String s){
        return new pDestination(s);
    }
    public Contents contents(){
        return new pContents();
    }
}

public class TestParcel{
    public static void main(String[] args){
        Parcel p = new Parcel();
        Contents c = p.contents();
        Destination d = p.destiantion("Tasmania");
    }
}///：~
```

Parcel 中添加了一些新的东西：内部类pContents是private，所以除了Parcel,没有人可以访问它，PDestination是protected的，所以只有Parcel,它的子类，以及和它同包的类可以访问PDestination，所以客户端程序员想要了解或访问这些成员是受到限制的。于是private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐匿了实现的细节，此外，从客户端程序员的角度看，由于不能访问任何新添加的，原本不属于公共接口的方法，所以扩展接口是没有价值的，这也给java编译器生成更高效代码的机会。

### **在方法和作用域内的内部类**
我们还可以在一个方法里面或者在任意的作用域内定义内部类，这被称作局部内部类，这么做有两个理由

+ 如前所示，你实现了某个类型的接口，于是可以创建并返回对其的引用
+ 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的

```
public class Parcel{
    public Destiantion destination(String s){
        class pDestination implements Destination{
            private String label;
            private pDestination(String whereTo){
                label = whereTo;
            }
            public String readLabel(){return label;}
        }
        return new pDestinaton(s);
    }
    public static void main(String[] args){
        Parcel p = new Parcel();
        Destination d = p.destination("Tasmania“);
    }
}///:~
```

pDestination类是destination()方法的一部分，而不是Parcel的一部分，所以，在destination()之外不能访问pDestination,注意出现在return语句中的向上转型----返回的是Destinaton的引用，他是pDestination的基类。

### **匿名内部类**

```
public class Parcel{
    public Contents contents(){
        return new Contents(){
            private int i = 11;
            public int value(){return i;}
        };//semicolon is required in this case
    }
    public static void main(String[] args){
        Parcel p = new Parcel();
        Contents c = p.Contents();
    }
}///：~
```

contents()方法将返回值的生成域表达这个返回值的类的定义结合在一起
这个看起来似乎是你正要创建一个Contents对象，但是然后(在到达语句结束的分号之前)，你却说："等等，我想在这里插入一个类的定义。"这种奇怪的语法指的是："创建一个继承自Contents的匿名类的对象。"通过new表达式返回的引用被自动向上转型为对Contents的引用。

如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么百年一起会要求其参数引用是fianl的，就像你在destination()的参数中看到的那样，如果你忘记了，你将会的到一个编译时错误信息。

通过实例初始化，就能偶达到为匿名内部类创建一个构造器的效果，就像这样：

```
abstract class Base{
    public Base(int i){
        System.out.println("Base constructor, i = " + i);
    }
    public abstract void f();
}

public class AnonymousConstructor{
    public static Base getBase(int i){
        return new Base(i){
            {System.out.println("Inside instance initializer");}
            public vodi f(){
            System.out.println("In anonymous f()");
            }
        };
    }
    public static vodi main(String[] args){
        Base base = getBase(47);
        base.f();
    }
}/*Output
Base constructor,i=47;
Inside instance initializer
In anonymous f()
*///:~
```

此例中不要求变量i一定是final的，因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用

### **嵌套类**
如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static，这通常被称为嵌套类(静态内部类）,因为static是属于类而不是属于对象的，嵌套类意味着

+ 要创建嵌套类的对象，并不需要其外围类的对象
+ 不能从嵌套类的对象中访问非静态的外类对象

嵌套类与普通的内部类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含以上所有东西

```
public calss Parcel{
    private static class ParcecContents implements Contents{
        private int i = 11;
        public int value(){return i;}
    }
    protected static class ParcelDestination
    implements Destination{
        private String label;
        private ParcelDestination(String whereTo){
            label = whereTo;
        }
        public String readLabel(){return label;}
        public static vodi f(){}
        static int x = 10;
        static class AnotherLevel{
            public static void f(){}
            static int x = 10;
            }
        }
    public static Destination destination(String s){
        return new ParcelDestinaiton(s);
    }
    public static Contents contents(){
        return new ParcelContents();
    }
    public static void main(String[] args){
        Contents c = contents();
        Destination d = destination("Tasmania");
    }
}///:~
```

#### **接口内部的类**
正常情况下，不能再接口内部放置任何代码，但嵌套类可以作为接口的一部分，你放到接口中的任何类都自动的是public和static的

```
public interface ClassInInterface{
    void howdy;
    class Test implements ClassInInterface{
        public void howdy(){
            System.out.println("Howdy!");
        }
    public static void main(String[] args){
        new Test().howdy();
        }
    }
}/*Output:
Howdy!
*///:~
```

如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部类的嵌套类会显得很方便。

有的人建议，在每一个类中都写一个mian()方法，用来测试这个类，这么做有个缺点，那就是必须带着那些已编译过的额外代码，如果这对你来说是个麻烦，那么你可以使用嵌套类来放置测试代码

```
public class TestBad{
    public void f(){System.out.println("f()");}
    public static class Tester{
        public static void main(String[] args){
            TestBed t = new TestBed();
            t.f();
        }
    }
}/*Output
f()
*///:~
```

#### **从多层嵌套类中访问外部类成员**
一个内部类被嵌套多少层并不重要，它能透明的访问所有它所嵌入的外围类的所有成员

```
class MNA{
    private void f(){}
    class A{
        private void g(){}
        public class B{
            void h();
            g();
            f();
        }
    }
}

public class MultiNestingAccess{
    public static void main(Stirng[] args){
        MNA mna = new MNA();
        MNA.A mnaa = mna.new A();
        MNA.A.B mnaab = mann.new B();
        mnaab.h();
    }
}///:~
```

---

## **7.容器**
容器主要分为collection类型和map类型

<center class = "rongqi">
    <img src="https://upload-images.jianshu.io/upload_images/13484241-c7487f902d2d3e5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"><img src="https://upload-images.jianshu.io/upload_images/13484241-a986a0478cf5b2b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/250">
</center>

---

### **Collection类型**
#### **Iterable**
Iterable接口（java.lang.Iterable）是Collection类型的根接口之一，Collection接口继承自Iterable接口，自然而然的所以搜有的Collection子类型也实现于Iterable接口
一个实现了Iterable接口的类的对象便可以使用for循环，下面是一个例子

```
List list = new ArrayList();

for(Object o : list){
    //do something o;    
}
```

整个Iterable接口中就只有一个方法

```
public interface Iterable<T> {
  public Iterator<T> iterator();    
}
```

用这个方法可以生成一个Iterator对象用来遍历集合，那么你可能会问，Iterable与Iterator有什么区别呢

---

#### **Iterable与Iterator的区别**
> * 首先Iterator，Iterable都是接口
> * Iterable接口中就只有一个能生成Iterator的方法
> * 为什么一定要去实现Iterable这个接口呢？ 为什么不直接实现Iterator接口呢？
看一下JDK中的集合类，比如List一族或者Set一族， 都是实现了Iterable接口，但并不直接实现Iterator接口，而是通过内部类实现的，每一个不同的collection类都通过自己的方式实现Iterator接口，每种集合类自己在内部实现这个Iterator接口的子类，然后集合类通过实现iterable接口返回这个Iterator接口子类的实例。这样呢通过Iterator接口可以让每一种集合类返回的Iterator具体类型可能不同，Array可能返回ArrayIterator，Set可能返回SetIterator，Tree可能返回TreeIterator，但是它们都实现了Iterator接口，因此，客户端不关心到底是哪种Iterator，它只需要获得这个Iterator接口即可，这就是面向对象的威力。而且Iterator中和核心的方法next(),hasnext(),remove(),都是依赖当前位置，如果这些集合直接实现Iterator，则必须包括当前迭代位置的指针。当集合在方法间进行传递的时候，由于当前位置不可知，所以next()之后的值，也不可知。而当实现Iterable则不然，每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响。
> * 你甚至可以创建一了你自己的collection类型的子类型

```
public class MyCollection<E> implements Iterable<E>{

    public Iterator<E> iterator() {
        return new MyIterator<E>();
    }
    public class MyIterator <T> implements Iterator<T> {

    public boolean hasNext() {
    
        //implement...
    }

    public T next() {
        //implement...;
    }

    public void remove() {
        //implement... if supported.
    }
}
public static void main(String[] args) {
    MyCollection<String> stringCollection = new MyCollection<String>();

    for(String string : stringCollection){
    .....
    }
}
}
```

---

#### **Collection集合**
collection的子接口:

+ List
+ SET
+ SortedSet
+ NavigableSet
+ Queue
+ Deque

Java并没有提供Collection接口的直接实现，所以你必须使用以上列出的子类型，但是Collection接口定义了一套所有子接口共享的方法，所以有些时候你在使用这些子接口时，大可不必过于在意你所使用的子接口的类型，把它当作集合类型就行了

使用接口的引用指向实现类的对象，与多态中超类的引用指向子类的对象从而通过后期绑定决定调用方法的原理相似

> * **在集合中添加或移除元素：**

```
String     anElement  = "an element";
Collection collection = new HashSet();

boolean didCollectionChange = collection.add(anElement);
boolean wasElementRemoved   = collection.remove(anElement);
```

add()方法将所给的元素添加到集合中，添加成功则返回true，否则返回false。可是如果集合时Set类型的对象，那么它会检查你所添加的元素是否在集合中已经存在，如果已经存在，则无法添加，这其中用到equal()方法。remove()将所给元素从集合中删除

你还可以同时一次性添加或删除多个元素

```
Set  aSet  = ... // get Set  with elements from somewhere
List aList = ... // get List with elements from somewhere

Collection collection = new HashSet();

collection.addAll(aSet);    //returns boolean too, but ignored here.
collection.addAll(aList);   //returns boolean too, but ignored here.

collection.removeAll(aList);   //returns boolean too...
collection.retainAll(aSet);    //returns boolean too...
```

使用addAll()方法会将参数集合中的所有元素添加到目标集合中，但是，如果此时使用add()方法，则会将整个参数集合作为一个元素添加到目标几何中，removeAll()方法会将目标集合中包含的所有参数集合中的元素删除，retainAll()的作用与其恰恰相反，不是删除所有存在的参数集合元素，而是保留它们，并删除所有其他元素，下面有一个用伪语言写的例子（pseudo language）

```
Collection colA = [A,B,C]
Collection colB = [1,2,3]

Collection target = [];

target.addAll(colA);     //target now contains [A,B,C]
target.addAll(colB);     //target now contains [A,B,C,1,2,3]

target.retainAll(colB);  //target now contains [1,2,3]

target.removeAll(colA);  //nothing happens - already removed
target.removeAll(colB);  //target is now empty.
```

> * **检查集合中是否含有某元素**
contains（）如果集合中含有此元素则返回true，containsAll()如果集合中含有所有参数集合中的元素，则返回true。

```
Collection collection   = new HashSet();
boolean containsElement = collection.contains("an element");

Collection elements     = new HashSet();
boolean containsAll     = collection.containsAll(elements);
```


> * **集合大小**
`int numberOfElements = collection.size(); `可以用来判断集合中元素数目

> * **遍历一个集合**
> 遍历一个集合有三种可行的方式

1.while-loop

```
List mylist = new ArrayList;
Iterator iterator = mylist.Iterator();
while(iterator.hasNext()){
    Object obj = iterator.next();
    .....
}
```

2.for-loop

```
List mylist =new ArrayList;
for(Object obj : mylist){
    .....
}
```

3.the common way

```
List mylist = new ArrayList;
for(i = 0;i<mylist.size();i++){
    Object obj = mylist.get();
}
```

---

#### **List集合**
> 作为Collection类型的一个亚类，Collection中定义的所有方法在List接口中也可以找到。由于List是一个接口，所以你要通过实现它来使用这个集合类型，以下是现有的几种实现类

+ java.util.ArratList
+ java.util.LinkedList
+ java.util.Vector
+ java.util.Stack

> * **如何向List中添加元素，获取元素**
使用从collection接口中继承而来的add()方法，get()方法，下面是一个例子

```
List listA = new ArrayList();

listA.add("element 0");
listA.add("element 1");
listA.add("element 2");

//access via index
String element0 = listA.get(0);
String element1 = listA.get(1);
String element3 = listA.get(2);


//access via Iterator
Iterator iterator = listA.iterator();
while(iterator.hasNext(){
  String element = (String) iterator.next();
}


//access via new for-loop
for(Object object : listA) {
    String element = (String) object;
}
```

> * **如何从List中移除元素**
你有两种方式可以选择:
remove(Object element)
remove(int index)

> * **如何清空一个List**
List接口含有一个clear()方法，可以一次性清空所有元素

> * **List大小**
List接口有一个size()方法，返回List集合中元素的个数

> * **泛型List**
默认的，你可以添加任何类型的object到List类集合中，但是利用java泛型，你可以限制加入到List集合的对象类型
`List<MyObject> list = new ArrayList<MyObject>();`因此，你便只能加入Myobject类型的对象到ArrayList集合中

> 有关List集合的遍历，在上面Collection类型中已经叙述过了，在此不在赘述

---

#### **Set集合**
Set与List相同，也是Collection接口的一个亚接口，实现了Set接口的类有：

+ java.util.EnumSet
+ java.util.HashSet
+ java.util.LinkedHashSet
+ java.util.TreeSet

以上四种是实现，每种实现在遍历时读取元素的顺序，以及在加入或获取元素时所耗费的时间也有所不同，HashSet是受HashMap支持，它无法保证你在遍历它时的顺序；LinkedMap不同于HashSet，你遍历它时元素的顺序就是当初插入时元素的顺序，TreeSet同样可以保证你遍历时元素的顺序，但是这个顺序是元素的自然顺序（就相当于你对一个List或者数组使用Collections.sort()方法），或者根据你所提供的特殊的Comparator来排序，下面是构建他们的办法：

```
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
```

> * **添加或者获取元素**
使用从Collection接口继承而来的add()方法

```
Set setA = new HashSet();

setA.add("element 1");
setA.add("element 2");
setA.add("element 3");
```

> * **移除元素**
你只能通过调用remove(Object o)方法来移除某些元素，而不能是某些引索值，因为元素的顺序是根据不同的Set实现类而有所不同的

> * **泛型Set**
限制Set集合中的元素类型，`Set<MyObject> set = new HashSet<MyObject>();`

---

#### **SortedSet集合**
> * java.util.SortedSet接口是java.util.Set接口的子接口，它的行为与Set行为差不多只不过它的元素是在内部被排序的，也就是说你在遍历SortedSet实现类的对象时，它所返回的元素的顺序时已经排序好的，这种顺序要么是自然的顺寻，要么是你提供给SortedSet的Comparator顺序
> * SortedSet只有一个实现类，那就是java.util.TreeSet，下面有一个使用SortedSet接口的例子

```
SortedSet setA = new TreeSet();

Comparator comparator = new MyComparator();
SortedSet setB = new TreeSet(comparator);
```

---

#### **NavigableSet集合**
java.util.NavagabelSet接口是java.util.SortedSet接口的子接口，它的行为与SortedSet相似而且正如所期望的那样，除了排序体系之外，这个接口还定义了导航方法体系，让我们来看看这些导航方法把

这个接口同样只有一个实现类，那就是java.util.TreeSet

> * **descendingIterator() and descendingSet()方法**
descendingSet()方法返回一个顺序与与原来相反的NavigableSet，这个返回的view其实是由原类型所支持的，所以你在改变这个倒叙set时，同样的变化也会反射到原来的set上，这又一个例子：
`NavigableSet reverse = original.descendingSet();`
descendingIterator()方法允许你倒叙遍历NavigableSet，同时不改变内部的元素顺序

> * **headSet(),tailSet() and SubSet()方法**
headSet()方法只返回一个view包含哪些比所给元素“小”的元素，下面是一个例子：

```
NavigableSet original = new TreeSet();
original.add("1");
original.add("2");
original.add("3");

//this headset will contain "1" and "2"
SortedSet headset = original.headSet("3");

//this headset will contain "1", "2", and "3" because "inclusive"=true
NavigableSet headset = original.headSet("3", true);
```

> tailSet()方法与headSet()相似，只不过它只返回比所给元素“大”的元素，subSet()则返回一个范围内的元素，下面有一个例子：

```
NavigableSet original = new TreeSet();
original.add("1");
original.add("2");
original.add("3");
original.add("4");
original.add("5");

//this subset will contain "2" and "3"
SortedSet    subset  = original.subSet("2", "4");

//this subset will contain "2", "3" and "4" because
//    fromInclusive=true, and toInclusive=true 
NavigableSet subset = original.subSet("2", true, "4", true);
```

> * **ceiling(),floor(),higher(),and lower()方法**
ceiling()方法返回比所给元素“大”的元素中最小的元素（包括其本身），floor()与其恰恰相反（也包括其本身），higher()与lower()则不包括其本身,上代码

```
NavigableSet original = new TreeSet();
original.add("1");
original.add("2");
original.add("3");

//ceiling will be "2".
Object ceiling = original.ceiling("2");

//floor will be "2".
Object floor = original.floor("2");

//higher will be "3".
Object higher = original.higher("2");

//lower will be "1"
Object lower = original.lower("2");
```

> * **pollFirst() and pollLast()方法**
pollFirst()返回并移除NavigableSet中第一个元素，pollLast()与其相对应，上代码：

```
NavigableSet original = new TreeSet();
original.add("1");
original.add("2");
original.add("3");


//first is "1"
Object first = original.pollFirst();

//last is "3"
Object last = original.pollLast();
```

---

### **Map类型**

#### **Map接口**
Map接口的实现类较多，有如下几种

+ java.util.HashMap
+ java.util.Hashtable
+ java.util.EnumMap
+ java.util.IdentityHashMap
+ java.util.LinkedHashMap
+ java.util.Properties
+ java.util.TreeMap
+ java.util.WeakHashMap

每个实现类型在遍历元素时的顺序和添加与获取元素所花费的时间是各不相同的
HashMap连接一个key与一个value，但是它并不保证内部元素的顺序
TreeMap同样连接一个Key与一个value，但是它可以保证key型set或者value型set遍历时的顺序

> * **添加获取元素的方法**
添加元素到Map()中你可以调用put()方法，下面是一个例子：

```
Map mapA = new HashMap();

mapA.put("key1", "element 1");
mapA.put("key2", "element 2");
mapA.put("key3", "element 3");
```

> 在Map类的容器中，你可以使用key来获取value，方法如下：
`String element1 = (String) mapA.get("key1");`
你有两种常用的方式可以用来遍历Map类容器：

```
Iterator iterator = mapA.keySet().iterator();
while(iterator.hasNext(){
  Object key   = iterator.next();
  Object value = mapA.get(key);
}

//access via new for-loop
for(Object key : mapA.keySet()) {
    Object value = mapA.get(key);
}

//access via new for-loop too
for(Object obj : mapA.value()){
    do something to obj;
}
```

> * **移除元素**
通过调用remove(Object key)的方式，你可移除符合key的一对（key,value）元素

> * **泛型Map**

```
Map<String, MyObject> map = new HashMap<String, MyObject>();
for(MyObject anObject : map.values()){
   //do someting to anObject...
}

for(String key : map.keySet()){
   MyObject value = map.get(key);
   //do something to value
}
```

##### **SortedMap**
java.util.SortedMap时java.util.Map接口的一个子接口，只不过其元素都在内部被排序储存了，储存的顺序就是其元素的自然顺序或者你所提供的comparator的顺序，这个接口只有一个实现类，那就是java.util.TreeMap类，下面有一个例子

```
SortedMap mapA = new TreeMap();

Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
```

##### **NavigableMap**
java.util.NavigableMap是java.util.SortedMap接口的一个子接口，在原接口中添加了一些导航类方法
> * **descendingKeySet() and descendingMap()**
descendingKeySet（）方法返回一个其中元素相对于原Key set倒序的NavigableSet，这个返回的view是由原key set所支持的，所以当你改变倒序集合时，该改变也会反射到原结合上，同时你不可以直接调用remove()方法除去key set集合中的某个元素，要调用Map.remove()方法.下面有一个例子`NavigableSet reverse = map.descendingKeySet();` descendingMap()方法大致相似，返回的是原Map的一个倒叙view，同样你改变此view的话，这样的变化也会体现在原Map上，下面有一个例子：`NavigableMap descending = map.descendingMap()`


> * headMap(),tailMap() and subMap()


---

## **8.通过异常处理错误**



---

## **9.字符串**

---

### **String对象**
> * String对象是不可变的，String类中每一个看上去会修改String值的方法实际上都是创建了一个全新的String对象
> * 不可变性会带来一定的效率问题，为String对象重载的“+”操作符就是一个例子，重载的意思是，一个操作符用于特定的类时，被赋予了特殊的意义，(用于String的“+”与“+=”时Java中仅有的两个重载过的操作符，而Java不允许程序员重载任何操作符)。在我们使用“+”操作符时，编译器自动引入了java.lang.StringBuilder类，并调用StringBuilder的Append（）方法，最后调用toString()生成结果。
> * 如果你要在toString()的方法中使用循环，那么最好自己创建一个StringBuilder对象，用它来构造最终结果。现采用两种方式生成一个String，方法一使用了多个String对象，方法二使用了StringBuilder。
```
public class WhitherStringBuilder{
  public String implicit(String[] fields){
    String result = "";
    for(int i  = 0;i < fields;i++){
      results += fields[i];
    return result;
    }
 }
public String explicit(String[] fields){
  StringBuilder result = new StringBuilder();
  for(int i = 0; i<fields;i++){
    result.append(fields[i]);
    }
  return result.toString();
 }
}///:~
```

> * StringBuilder提供了丰富而全面的方法，包括insert(),repleace(),substring()甚至reverse(),最常用的还是append()，toString()和delete()方法.

### **正则表达式**
> * 正则表达式是一种强大而灵活的文本处理工具，使用正则表达式，我们能以编程的方式，构造复杂的文本模式，并对输入的字符进行搜索。一般来说，正则表达式就是以某种方式来描述字符串。
> * 如果你在其他语言中使用过正则表达式，那你立刻就能发现Java对反斜线\的不同处理，在其他语言中，`\\`表示“我想在正则表达式中插入一个普通的（字面上的）反斜线，它没有特殊意义。”而在java中，`\\`的意思是“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。”例如，如果你想表示一个数字，那么正则表达式应该是`\\d`，如果你想插入一个普通的反斜线，则应该这样`\\\\`，不过换行符和制表符之类的东西只需使用反斜线：`\n\t`.

###  **创建正则表达式**

#### **字符：**

|字符    |意义       |
|--------|-----------|
|B|指定字符B|
|\xhh|十六进制值为oxhh的字符|
|\uhhhh|十六进制为oxhhhh的Unicode字符|
|\t|制表符Tab|
|\n|换行符|
|\r|回车|
|\f|换页|
|\e|转义Escape|

#### **字符类**

|字符类|意义|
|---------|---------|
|.|任意字符|
|[abc]|a或b或c|
|[^abc]|除了a,b,c以外的任何字符|
|[a-zA-Z]|从a到z或从A到Z的任何字符|
|[ abc[hij] ]|任意a,b,c,h,i,j字符|
|[ a-z&&[hij] ]|任意h,i,j字符|
|\s|空白符|
|\S|非空白符|
|\d|数字0-9|
|\D|非数字|
|\w|词字符[a-zA-Z0-9]|
|\W|非词字符|

#### **逻辑操作符**

|逻辑操作符|意义|
|-----------|----------|
|XY|Y跟在X后面|
|XdelimiterY| X或Y|
|(X)|捕获组|

#### **边界匹配符**

|边界匹配符|意义|
|--------|--------|
|^|一行的起始|
|$|一行的结束|
|\b|词的边界|
|\B|非词的边界|
|\G|前一个匹配的结果|

#### **量词**

|贪婪型|勉强型|占有型|如何匹配|
|---------------|---------------|---------------|---------------|
|X?|X??|X?+ | 零个或一个X|
|X星|X星？|X星+|零个或多个X|
|X+|X+？|X++|一个或多个X|
|X{n}|X{n}?|X{n}+|恰好n次X|
|X{n.}|X{n,}?|X{n,}+|至少n次X|
|X{n,m}|X{n,m}?|X{n,m}+|X至少n次，且不超过m次|

> * 贪婪型：贪婪表达式会为所有可能的模式发现尽可能多的匹配
> * 勉强型：用问号来指定，这个量词匹配满足模式所需的最少字符数
> * 占有型：目前，这种类型只有在java中才可以使用，当正则表达式被用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯，而占有的量词并不保存这些中间状态，因此它们可以防止回溯，它们常常用于防止正则表达式失控，因此正则表达式使用起来更有效

### **Pattern和Matcher**

#### **Pattern方法**
> Pattern类是java正则表达式中非常重要的切入对象，一般来说，比起功能有限的String类，我们更愿意构建功能强大的正则表达式对象。

> * Pattern.matches(): 将一个文本（String）与一个正则表达式匹配（regular expression pattern）的最简单的方式就是使用Pattern.matches这个静态方法，下面的代码是这个方法使用的例子

```
import java.util.regex.Pattern;

public class PatternMatchesExample {

    public static void main(String[] args) {

        String text    =
            "This is the text to be searched " +
            "for occurrences of the pattern.";

        String pattern = ".*is.*";

        boolean matches = Pattern.matches(pattern, text);

        System.out.println("matches = " + matches);
    }
}
```

如果你只需要对此文本和正则表达式进行一次匹配，那么这个方法是完全可以的，但如果你想发现多个匹配，或者不想使用默认的设定，那么你需要使用一个Pattern对象

> * Pattern.compile(): 如果用一个正则表达式对一个文本匹配多次，你就需要创建一个Pattern的实例对象，此时就会用到Pattern.compile()这个方法

```
import java.util.regex.Pattern;

public class PatternCompileExample {

    public static void main(String[] args) {

        String text    =
                "This is the text to be searched " +
                "for occurrences of the http:// pattern.";

        String patternString = ".*http://.*";

        Pattern pattern = Pattern.compile(patternString);
    }
}
```

再次方法中，你还可以加入falg参数

|变异标记|效果|
|------|------|
|Pattern.CANON_EQ|两个字符当且仅当它们的完全规范分解相匹配时，就认为它们是想匹配的|
|Pattern.CASE_INSENSITIVE(?i)|默认情况下，大小写不敏感的匹配只有US_ASCII字符集中的字符才能进行，这个标记允许匹配模式不必考虑大小写|
|Pattern.COMMENTS(?x)|在这种模式下，空格符被忽略掉，并且以#开始到行末的注释也会被忽略掉|
|Pattern.DoTall(?s)|在此模式中，表达式“.”匹配所有字符，包括行终结符，默认情况下，"."表达式不匹配行终结符|
|Pattern.MULTILINE(?m)|在多行模式下，表达式^和$分别匹配一行的开始和结尾|
|Pattern.UNICODE_CASE(?u)|当指定这个标记，并且开启CASE_INSENSITIVE时，大小写不敏感的匹配将按照Unicode标注相一致的标准进行|
|Pattern.UNIX_LINES(?d)|在这种模式下，在`. ^ $ `行为中，只识别终止符\n|

> * Pattern.split(): 此方法用来将文本断开成字符串对象数组，断开的边界由正则表达式决定（pattern）,同时也可以添加一个int型参数，限制文本被分割成的字符串的数量，如pattern.split(text,3)

```
import java.util.regex.Pattern;

public class PatternSplitExample {

    public static void main(String[] args) {
    
        String text = "A sep Text sep With sep Many sep Separators";
        
        String patternString = "sep";
        Pattern pattern = Pattern.compile(patternString);
        
        String[] split = pattern.split(text);
        
        System.out.println("split.length = " + split.length);
        
        for(String element : split){
            System.out.println("element = " + element);
        }
    }
}
```


#### **Matcher方法**
> Java Matcher类可以用来在一个文本中多次匹配一个正则表达式，也可以用来在多个不同的文本中匹配某一相同正则表达式

> * Matcher.matches()： 如果正则表达式匹配整个文本那么就返回true否则返回flase，你无法使用此方法在一个文本中进行多次匹配，要想实现多次匹配，你需要使用find() start() end()等方法。

> * Matcher.lookingAt(): 这么方法与matches差不多，最大的区别就是matches匹配的是lookingAt()只匹配文本的开头，文本的开有满足正则表达式就返回true，否则返回flase，而matches匹配的是整个文本

```
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class CreateMatcherExample {

    public static void main(String[] args) {

        String text    =
                "This is the text to be searched " +
                "for occurrences of the http:// pattern.";

        String patternString = "This is the";

        Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(text);

        System.out.println("lookingAt = " + matcher.lookingAt());
        System.out.println("matches   = " + matcher.matches());
    }
}/*Output
true
false
*////:~
```

> * find()+Stard()+end():
Mather.find()方法查找传递给Pattern.matcher(text)方法的参数text文本中所有正则表达式的匹配，当Matcher被创建的时候，文本中所有的匹配就已经被发现了，find()方法会指向第一个出现的匹配，接下来的调用会让find()方法指向下一处的匹配，start()和end()方法会返回匹配的开始处和结束处的字符的引索值，下面有一个例子


```
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class MatcherFindStartEndExample {

    public static void main(String[] args) {

        String text    =
                "This is the text which is to be searched " +
                "for occurrences of the word 'is'.";

        String patternString = "is";

        Pattern pattern = Pattern.compile(patternString);
        Matcher matcher = pattern.matcher(text);

        int count = 0;
        while(matcher.find()) {
            count++;
            System.out.println("found: " + count + " : "
                    + matcher.start() + " - " + matcher.end());
        }
    }
}/*Output
found: 1 : 2 - 4
found: 2 : 5 - 7
found: 3 : 23 - 25
found: 4 : 70 - 72
*////:~
```

> * reset()： 将匹配重置为文本开头的匹配

> * group()： 如果我们想在文本中提取多个相似的信息，用group将会非常方便 在正则表达式中，groups是由括号标记的，但是括号不包括在匹配内容之中，我们所匹配的是括号中的内容，group(int groupNo)所带的参数的作用是让正则表达式指向不同的括号内的内容，下面有两个例子：

```
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class MatcherGroupExample {
    public static void main(String[] args) {
        String text    =
                  "John writes about this, and John Doe writes about that," +
                          " and John Wayne writes about everything.";
        String patternString1 = "(John) (.+?) ";
        Pattern pattern = Pattern.compile(patternString1);
        Matcher matcher = pattern.matcher(text);
        while(matcher.find()) {
            System.out.println("found: " + matcher.group(1) +
                               " "       + matcher.group(2));
        }
    }
}/*Output
found: John Writes
found: John Doe
found: John Wayne
*////:~
```

```
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class MatcherGroupsExample {

    public static void main(String[] args) {

        String text    =
                  "John writes about this, and John Doe writes about that," +
                          " and John Wayne writes about everything."
                ;

        String patternString1 = "((John) (.+?)) ";

        Pattern pattern = Pattern.compile(patternString1);
        Matcher matcher = pattern.matcher(text);

        while(matcher.find()) {
            System.out.println("found: <"  + matcher.group(1) +
                               "> <"       + matcher.group(2) +
                               "> <"       + matcher.group(3) + ">");
        }
    }
}/*Output
found: <John writes> <John> <writes>
found: <John Doe> <John> <Doe>
found: <John Wayne> <John> <Wayne>
*////:~
```

> * replaceAll()+replaceFirst()： 这两个方法被用来替换Matcher对象搜寻对象的部分字符串，replaceAll()式替换所有的匹配，replaceFirst()则只替换第一个，下面有一个例子

```
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class MatcherReplaceExample {

    public static void main(String[] args) {

        String text    =
                  "John writes about this, and John Doe writes about that," +
                          " and John Wayne writes about everything."
                ;

        String patternString1 = "((John) (.+?)) ";

        Pattern pattern = Pattern.compile(patternString1);
        Matcher matcher = pattern.matcher(text);

        String replaceAll = matcher.replaceAll("Joe Blocks ");
        System.out.println("replaceAll   = " + replaceAll);

        String replaceFirst = matcher.replaceFirst("Joe Blocks ");
        System.out.println("replaceFirst = " + replaceFirst);
    }
}/*Output
replaceAll   = Joe Blocks about this,and Joe Blocks writes about that,and Joe Blocks writes about everything.
replaceFirst = Joe Blocks about this,and John Doe writes about that,and John Wayne writes about everything.*////:~
```

> * appendReplacement()+appendTail(): appendRepalcement()方法被用来将最近的匹配被替换后的文本尾至上一次匹配处的文本位（如果是第一次，则是文本的开头）append()到一个StringBuffer()中，直到最后一个匹配处被find。通常最后一个匹配的位置不一定文本的末尾，所以有appendTail()方法添加文本末尾


---

## **10.信息类型**

--

## **11.泛型**



---

## **12.数组**

Java语言中，由于把二维数组看作是数组的数组，数组空间不是连续分配的，所以不要求二维数组每一维的大小相同。
如果定义时指定了数组初始化操作，则不能定义维表达式。

---

## **13.容器深入研究**

---

## **14.java I/O系统**

### **主要的类**

```graphRL
    A[FileReader]-->|extends| B[InputStreamReader]
    C[BerfferedReader]-->|extends| D[Reader]
    B[InputStreamReader]-->|extends| D[Reader]
    E[BufferedWriter]-->|extends| F[Writer]
    G[OutputStreamWriter]-->|extends| F[Writer]
    F[Writer]-->|  | H[字符流]
    D[Reader]-->|  | H[字符流]
    I[BufferedInputStream]-->|extends| J[FilterInputStream]
    J[FilterInputStream]-->|extends| K[InputStream]
    L[FileInputStream]-->|extends| K[InputStream]
    M[BufferedOutputStream]-->|extends| N[FilterOutputStream]
    O[FileOutoutStream]-->|extends| P[OutputStream]
    N[FilterOutputStream]-->|extends| P[OutputStream]
    K[InputStream]-->|  | R[字节流]
    P[OutputStream]-->|  | R[字节流]
```

---

## **15.枚举类型**

---

## **16.注释**

---

## **17.并发**

---

## **18.图形化用户界面**

### **AWT库**

```graphRL
    A[JButton]-->|extends| F[JComponent];
    B[JPanel]-->|extends| F[JComponent];
    C[JLabel]-->|extends| F[JComponent]
    D[JList]-->|extends| F[JComponent]
    E[...]-->|extends| F[JComponent]
    F[JComponent]-->|extends| G[Container]
    H[Windows]-->|extends| G[Container]
    I[JFrame]-->|extends| H[Windows]
    J[JDialog]-->|extends| H[Windows]
    G[Container]-->|extends| K[Component]
```

```graphRL
    L[MouseEvent]-->|implements| M[InputEvent]
    N[KeyEvent]-->|implements| M[InputEvent]
    O[WindowsEvent]-->|implements| P[ComponentEvent]
    Q[FoucusEvent]-->|implements| P[ComponentEvent]
    R[ContainEvent]-->|implements| P[ComponentEvent]
    M[InputEvent]-->|implements| P[ComponentEvent]
    P[ComponentEvent]-->|implements| S[AWTEvent]
```

### **常用的几个类**

+ JFrame
+ JList
+ JLabel
+ JButton
+ JPanel

我们使用JFrame来创建一个图形化界面，我们可以自定义其的大小，布局，标题，初始化位置，还有其内部的组件布局,注意在创建一了JFrame类时，我们把这些除组件布局外的基本初始化写在构造函数的后面，不然在实例化窗口对象时会出现组件不可见的情况

```
public class MyFrame extends JFrame{
    private Container container;
    private JButton button;
    
    public MyFrame(){
        container = this.getContentPane();
        button = new JButton("My Button");
        container.add(button);
        container.setLayout(New FlowLayout());
        
        this.setTitle("My Frame");
        this.setSize(600,800);
        this.setDefaluteCloseOperation(JFrame.Exit_On_Close);
        this.setVisible(true);
    }
}
```

这样一个最简单的窗口就构建完毕了，如果你想要在窗口关闭时执行一些操作，你可以

```
addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                super.windowClosing(e);
                //the operation you want to do
            }
        });
```

JList时功能非常强大的一个组件，你可以对其任意一个单位添加监控，操作如下

```
list.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    if(e.getClickCount()==2){
                        //···
                    }
                }
            });
```

你还可以给Jlist组件添加一个scrollPanel

```
JScrollPane scrollPane = new JScrollPane();
            scrollPane.setBounds(80,132,369,213);
            scrollPane.setViewportView(list);
            panel.add(scrollPane);//the panel is a component which the list attached to;
```

### **JavaFx**


---

## **结语：**

---







[^footnote]: 域:field，是一种属性，可以是一个类的变量，一个对象的变量，一个对象中方法的变量，亦或者是一个函数的参数。


[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
